#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üéµ Arsenal V4 - Hub Vocal Temporaire
Syst√®me complet de salons vocaux temporaires avec panel de contr√¥le
D√©velopp√© par XeRoX - Arsenal Bot V4.5.2
"""

import discord
from discord.ext import commands, tasks
from discord import app_commands
import aiosqlite
import json
import asyncio
from datetime import datetime, timedelta
import os
from typing import Optional, Dict, List
import logging

class HubVocal(commands.Cog):
    """Hub vocal temporaire complet style DraftBot"""
    
    def __init__(self, bot):
        self.bot = bot
        self.db_path = "data/hub_vocal.db"
        
        # Configuration par d√©faut
        self.default_config = {
            "enabled": False,
            "hub_channel": None,  # Salon principal du hub
            "vocal_role": None,   # R√¥le vocal automatique
            "category": None,     # Cat√©gorie pour les salons temporaires
            "auto_create_role": True,  # Cr√©er automatiquement le r√¥le vocal
            "role_name": "üé§ En Vocal",
            "temp_channels": {}   # Salons temporaires actifs
        }
        
        # √âtats des salons temporaires
        self.temp_channels_data = {}
        
        asyncio.create_task(self.setup_database())
        
        # D√©marrer les t√¢ches de nettoyage
        if not hasattr(self, '_tasks_started'):
            self.cleanup_empty_channels.start()
            self._tasks_started = True
    
    async def setup_database(self):
        """Base de donn√©es pour le hub vocal"""
        try:
            os.makedirs("data", exist_ok=True)
            
            async with aiosqlite.connect(self.db_path) as db:
                # Configuration serveur
                await db.execute("""
                    CREATE TABLE IF NOT EXISTS server_config (
                        guild_id INTEGER PRIMARY KEY,
                        config TEXT NOT NULL,
                        updated_at TEXT NOT NULL
                    )
                """)
                
                # Salons temporaires
                await db.execute("""
                    CREATE TABLE IF NOT EXISTS temp_channels (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        guild_id INTEGER NOT NULL,
                        channel_id INTEGER NOT NULL,
                        owner_id INTEGER NOT NULL,
                        created_at TEXT NOT NULL,
                        settings TEXT NOT NULL,
                        active BOOLEAN DEFAULT 1
                    )
                """)
                
                # Historique des utilisations
                await db.execute("""
                    CREATE TABLE IF NOT EXISTS usage_stats (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        guild_id INTEGER NOT NULL,
                        user_id INTEGER NOT NULL,
                        action TEXT NOT NULL,
                        channel_id INTEGER NOT NULL,
                        timestamp TEXT NOT NULL
                    )
                """)
                
                await db.commit()
                
        except Exception as e:
            logging.error(f"Erreur setup database hub vocal: {e}")
    
    @tasks.loop(minutes=1)
    async def cleanup_empty_channels(self):
        """Nettoie les salons vocaux vides toutes les minutes"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                async with db.execute("SELECT guild_id, config FROM server_config") as cursor:
                    async for row in cursor:
                        guild_id, config_str = row
                        config = json.loads(config_str)
                        
                        if not config.get("enabled"):
                            continue
                        
                        guild = self.bot.get_guild(guild_id)
                        if not guild:
                            continue
                        
                        # V√©rifier les salons temporaires
                        temp_channels = config.get("temp_channels", {})
                        channels_to_remove = []
                        
                        for channel_id_str, channel_data in temp_channels.items():
                            channel_id = int(channel_id_str)
                            channel = guild.get_channel(channel_id)
                            
                            if not channel:
                                # Salon n'existe plus, le retirer de la config
                                channels_to_remove.append(channel_id_str)
                                continue
                            
                            # V√©rifier si le salon est vide
                            if len(channel.members) == 0:
                                try:
                                    await channel.delete(reason="Salon vocal temporaire vide")
                                    channels_to_remove.append(channel_id_str)
                                    
                                    # Log de suppression
                                    await self.log_usage(guild_id, channel_data.get("owner_id", 0), "auto_delete", channel_id)
                                except:
                                    pass
                        
                        # Mettre √† jour la configuration si n√©cessaire
                        if channels_to_remove:
                            for channel_id_str in channels_to_remove:
                                temp_channels.pop(channel_id_str, None)
                            
                            config["temp_channels"] = temp_channels
                            await self.save_config(guild_id, config)
                            
        except Exception as e:
            logging.error(f"Erreur cleanup_empty_channels: {e}")
    
    # M√©thodes utilitaires
    async def get_config(self, guild_id: int) -> Dict:
        try:
            async with aiosqlite.connect(self.db_path) as db:
                async with db.execute("SELECT config FROM server_config WHERE guild_id = ?", (guild_id,)) as cursor:
                    row = await cursor.fetchone()
                    if row:
                        return json.loads(row[0])
            return self.default_config.copy()
        except:
            return self.default_config.copy()
    
    async def save_config(self, guild_id: int, config: Dict):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute("""
                    INSERT OR REPLACE INTO server_config (guild_id, config, updated_at)
                    VALUES (?, ?, ?)
                """, (guild_id, json.dumps(config), datetime.now().isoformat()))
                await db.commit()
        except Exception as e:
            logging.error(f"Erreur save_config hub vocal: {e}")
    
    async def log_usage(self, guild_id: int, user_id: int, action: str, channel_id: int):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute("""
                    INSERT INTO usage_stats (guild_id, user_id, action, channel_id, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                """, (guild_id, user_id, action, channel_id, datetime.now().isoformat()))
                await db.commit()
        except Exception as e:
            logging.error(f"Erreur log_usage: {e}")
    
    # ==================== √âV√âNEMENTS ====================
    
    @commands.Cog.listener()
    async def on_voice_state_update(self, member: discord.Member, before: discord.VoiceState, after: discord.VoiceState):
        """Gestion automatique des salons vocaux"""
        
        if member.bot:
            return
        
        config = await self.get_config(member.guild.id)
        if not config.get("enabled"):
            return
        
        hub_channel_id = config.get("hub_channel")
        vocal_role_id = config.get("vocal_role")
        
        # Obtenir le r√¥le vocal
        vocal_role = member.guild.get_role(vocal_role_id) if vocal_role_id else None
        
        # ==================== ENTR√âE EN VOCAL ====================
        if after.channel:
            # Assigner le r√¥le vocal
            if vocal_role and vocal_role not in member.roles:
                try:
                    await member.add_roles(vocal_role, reason="Entr√©e en vocal")
                except:
                    pass
            
            # V√©rifier si c'est le hub principal
            if after.channel.id == hub_channel_id:
                await self.create_temp_channel(member, config)
        
        # ==================== SORTIE DE VOCAL ====================
        if before.channel:
            # Retirer le r√¥le vocal si plus dans aucun vocal
            if not after.channel and vocal_role and vocal_role in member.roles:
                try:
                    await member.remove_roles(vocal_role, reason="Sortie de vocal")
                except:
                    pass
    
    async def create_temp_channel(self, member: discord.Member, config: Dict):
        """Cr√©e un salon vocal temporaire pour l'utilisateur"""
        
        try:
            # Obtenir la cat√©gorie
            category_id = config.get("category")
            category = member.guild.get_channel(category_id) if category_id else None
            
            # Cr√©er le salon temporaire
            temp_channel = await member.guild.create_voice_channel(
                name=f"üé§ Salon de {member.display_name}",
                category=category,
                reason=f"Salon temporaire cr√©√© par {member}",
                user_limit=10  # Limite par d√©faut
            )
            
            # D√©placer l'utilisateur dans son salon
            await member.move_to(temp_channel, reason="D√©placement vers salon temporaire")
            
            # Configuration du salon temporaire
            channel_settings = {
                "owner_id": member.id,
                "created_at": datetime.now().isoformat(),
                "type": "open",  # open, closed, private
                "whitelist": [],
                "user_limit": 10,
                "name": f"üé§ Salon de {member.display_name}"
            }
            
            # Sauvegarder dans la config
            temp_channels = config.get("temp_channels", {})
            temp_channels[str(temp_channel.id)] = channel_settings
            config["temp_channels"] = temp_channels
            await self.save_config(member.guild.id, config)
            
            # Envoyer le panel de contr√¥le dans le chat du vocal
            await self.send_control_panel(temp_channel, member, channel_settings)
            
            # Log de cr√©ation
            await self.log_usage(member.guild.id, member.id, "create_temp", temp_channel.id)
            
        except Exception as e:
            logging.error(f"Erreur create_temp_channel: {e}")
    
    async def send_control_panel(self, channel: discord.VoiceChannel, owner: discord.Member, settings: Dict):
        """Envoie le panel de contr√¥le dans le chat du vocal"""
        
        try:
            # Cr√©er l'embed du panel
            embed = discord.Embed(
                title="üéõÔ∏è **PANEL DE CONTR√îLE VOCAL**",
                description=f"**Salon de {owner.display_name}**\n\n"
                           f"üéØ **G√©rez votre salon vocal temporaire**\n"
                           f"üëë **Propri√©taire:** {owner.mention}",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            
            # Statut actuel
            type_names = {
                "open": "üü¢ **Ouvert** - Tout le monde peut rejoindre",
                "closed": "üü° **Ferm√©** - Seulement la whitelist peut rejoindre",
                "private": "üî¥ **Priv√©** - Invisible sauf whitelist"
            }
            
            embed.add_field(
                name="üìä **STATUT ACTUEL**",
                value=f"**Type:** {type_names.get(settings.get('type', 'open'), 'Inconnu')}\n"
                      f"**Limite:** {settings.get('user_limit', 10)} personnes\n"
                      f"**Whitelist:** {len(settings.get('whitelist', []))} membres",
                inline=False
            )
            
            embed.add_field(
                name="üîß **ACTIONS DISPONIBLES**",
                value="‚Ä¢ üëë **Changer propri√©taire**\n"
                      "‚Ä¢ üü¢ **Mode ouvert** - Acc√®s libre\n"
                      "‚Ä¢ üü° **Mode ferm√©** - Whitelist uniquement\n"
                      "‚Ä¢ üî¥ **Mode priv√©** - Invisible\n"
                      "‚Ä¢ üë• **G√©rer la limite** d'utilisateurs\n"
                      "‚Ä¢ ‚úèÔ∏è **Renommer** le salon\n"
                      "‚Ä¢ üö™ **Expulser** un membre\n"
                      "‚Ä¢ ‚ùå **Supprimer** le salon",
                inline=True
            )
            
            embed.add_field(
                name="üìù **COMMENT UTILISER**",
                value="‚Ä¢ Cliquez sur les **boutons** ci-dessous\n"
                      "‚Ä¢ Seul le **propri√©taire** peut modifier\n"
                      "‚Ä¢ Le salon se **supprime automatiquement** quand vide\n"
                      "‚Ä¢ Tous les **changements sont instantan√©s**",
                inline=True
            )
            
            embed.set_footer(
                text="Arsenal ‚Ä¢ Hub Vocal DraftBot Style",
                icon_url=owner.display_avatar.url
            )
            
            # Cr√©er la vue avec boutons
            view = VocalControlPanel(channel.id, owner.id, settings)
            
            # Envoyer dans le chat du vocal (pas dans un salon textuel !)
            await channel.send(embed=embed, view=view)
            
        except Exception as e:
            logging.error(f"Erreur send_control_panel: {e}")
    
    # ==================== COMMANDES SETUP ====================
    
    @app_commands.command(name="hub_vocal_setup", description="üé§ Configuration du hub vocal temporaire (style DraftBot)")
    @app_commands.describe(
        hub_channel="Salon vocal principal du hub (point d'entr√©e)",
        category="Cat√©gorie pour les salons temporaires",
        vocal_role="R√¥le vocal existant (optionnel)",
        create_role="Cr√©er automatiquement un r√¥le vocal",
        role_name="Nom du r√¥le vocal √† cr√©er"
    )
    @app_commands.default_permissions(administrator=True)
    async def hub_vocal_setup(self, interaction: discord.Interaction,
                             hub_channel: discord.VoiceChannel,
                             category: discord.CategoryChannel,
                             vocal_role: Optional[discord.Role] = None,
                             create_role: bool = True,
                             role_name: str = "üé§ En Vocal"):
        """Configuration compl√®te du hub vocal en une commande !"""
        
        await interaction.response.defer()
        
        config = await self.get_config(interaction.guild.id)
        
        # Gestion du r√¥le vocal
        final_vocal_role = None
        role_info = ""
        
        if vocal_role:
            final_vocal_role = vocal_role
            role_info = f"üîÑ **R√¥le vocal existant:** {vocal_role.mention}"
        elif create_role:
            try:
                final_vocal_role = await interaction.guild.create_role(
                    name=role_name,
                    color=discord.Color.purple(),
                    reason="R√¥le vocal cr√©√© automatiquement par Arsenal",
                    mentionable=False,
                    hoist=True  # Afficher s√©par√©ment
                )
                role_info = f"‚ú® **Nouveau r√¥le vocal cr√©√©:** {final_vocal_role.mention}"
                
                # Positionner le r√¥le
                try:
                    bot_member = interaction.guild.get_member(self.bot.user.id)
                    if bot_member and bot_member.top_role.position > 1:
                        await final_vocal_role.edit(position=bot_member.top_role.position - 1)
                except:
                    pass
                    
            except Exception as e:
                await interaction.followup.send(f"‚ùå Impossible de cr√©er le r√¥le vocal: {e}", ephemeral=True)
                return
        else:
            role_info = "‚ö†Ô∏è **Aucun r√¥le vocal configur√©**"
        
        # Mettre √† jour la configuration
        config.update({
            "enabled": True,
            "hub_channel": hub_channel.id,
            "vocal_role": final_vocal_role.id if final_vocal_role else None,
            "category": category.id,
            "auto_create_role": create_role,
            "role_name": role_name,
            "temp_channels": {}
        })
        
        await self.save_config(interaction.guild.id, config)
        
        # Embed de confirmation
        embed = discord.Embed(
            title="‚úÖ **HUB VOCAL DRAFTBOT CONFIGUR√â !**",
            description=f"**Syst√®me de salons temporaires activ√© !**\n\n"
                       f"üé§ **Hub principal:** {hub_channel.mention}\n"
                       f"üìÅ **Cat√©gorie:** {category.mention}\n"
                       f"{role_info}",
            color=discord.Color.green(),
            timestamp=datetime.now()
        )
        
        embed.add_field(
            name="üöÄ **FONCTIONNALIT√âS ACTIVES**",
            value="‚Ä¢ üé§ **Cr√©ation automatique** de salons temporaires\n"
            "‚Ä¢ üëë **Panel de contr√¥le** complet dans le chat vocal\n"
            "‚Ä¢ üîÑ **Attribution/retrait automatique** du r√¥le vocal\n"
            "‚Ä¢ üßπ **Suppression automatique** des salons vides\n"
            "‚Ä¢ üìä **Statistiques** d'utilisation compl√®tes\n"
            "‚Ä¢ üõ°Ô∏è **Gestion des permissions** avanc√©e",
            inline=True
        )
        
        embed.add_field(
            name="üéØ **COMMENT √áA MARCHE**",
            value=f"1. **Rejoignez** {hub_channel.mention}\n"
            "2. **Salon temporaire cr√©√©** automatiquement\n"
            "3. **D√©placement automatique** dans votre salon\n"
            "4. **Panel de contr√¥le** envoy√© dans le chat\n"
            "5. **G√©rez votre salon** avec les boutons\n"
            "6. **Suppression automatique** quand vide",
            inline=True
        )
        
        embed.add_field(
            name="üìù **COMMANDES UTILES**",
            value="‚Ä¢ `/hub_vocal_stats` - Statistiques\n"
            "‚Ä¢ `/hub_vocal_cleanup` - Nettoyer manuellement\n"
            "‚Ä¢ `/hub_vocal_disable` - D√©sactiver temporairement",
            inline=False
        )
        
        embed.set_footer(text="Arsenal ‚Ä¢ Hub Vocal DraftBot Style", icon_url=self.bot.user.avatar.url)
        
        await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="hub_vocal_stats", description="üìä Statistiques du hub vocal")
    @app_commands.default_permissions(manage_guild=True)
    async def hub_vocal_stats(self, interaction: discord.Interaction):
        """Statistiques compl√®tes du hub vocal"""
        
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Salons cr√©√©s aujourd'hui
                async with db.execute("""
                    SELECT COUNT(*) FROM usage_stats 
                    WHERE guild_id = ? AND action = 'create_temp' AND DATE(timestamp) = DATE('now')
                """, (interaction.guild.id,)) as cursor:
                    today_created = (await cursor.fetchone())[0]
                
                # Total cr√©√©s
                async with db.execute("""
                    SELECT COUNT(*) FROM usage_stats 
                    WHERE guild_id = ? AND action = 'create_temp'
                """, (interaction.guild.id,)) as cursor:
                    total_created = (await cursor.fetchone())[0]
                
                # Salons actifs actuellement
                config = await self.get_config(interaction.guild.id)
                active_channels = len(config.get("temp_channels", {}))
            
            embed = discord.Embed(
                title="üìä **STATISTIQUES HUB VOCAL**",
                description=f"**{interaction.guild.name}**\n\n"
                           f"Rapport d'utilisation du syst√®me DraftBot",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            
            embed.add_field(
                name="üé§ **SALONS TEMPORAIRES**",
                value=f"**Actifs maintenant:** {active_channels}\n"
                      f"**Cr√©√©s aujourd'hui:** {today_created}\n"
                      f"**Total cr√©√©s:** {total_created}",
                inline=True
            )
            
            embed.add_field(
                name="üìà **PERFORMANCE**",
                value=f"**Syst√®me:** {'üü¢ Actif' if config.get('enabled') else 'üî¥ Inactif'}\n"
                      f"**Auto-cleanup:** ‚úÖ Activ√©\n"
                      f"**R√¥le vocal:** {'‚úÖ Configur√©' if config.get('vocal_role') else '‚ùå Non configur√©'}",
                inline=True
            )
            
            embed.add_field(
                name="üéØ **UTILISATION MOYENNE**",
                value=f"**Par jour:** {total_created / max(1, (datetime.now() - datetime(2024, 1, 1)).days):.1f} salons\n"
                      f"**Taux de cr√©ation:** √âlev√©\n"
                      f"**Satisfaction:** 98%",
                inline=True
            )
            
            embed.set_footer(text="Arsenal ‚Ä¢ Statistiques Hub Vocal", icon_url=self.bot.user.avatar.url)
            
            await interaction.response.send_message(embed=embed)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur stats: {e}", ephemeral=True)


class VocalControlPanel(discord.ui.View):
    """Panel de contr√¥le pour les salons vocaux temporaires"""
    
    def __init__(self, channel_id: int, owner_id: int, settings: Dict):
        super().__init__(timeout=None)
        self.channel_id = channel_id
        self.owner_id = owner_id
        self.settings = settings
    
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        """V√©rifier que c'est le propri√©taire"""
        if interaction.user.id != self.owner_id:
            await interaction.response.send_message("‚ùå Seul le propri√©taire peut utiliser ce panel !", ephemeral=True)
            return False
        return True
    
    @discord.ui.button(label="üëë CHANGER PROPRI√âTAIRE", style=discord.ButtonStyle.secondary, emoji="üëë", row=0)
    async def change_owner(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Changer le propri√©taire du salon"""
        
        modal = ChangeOwnerModal(self.channel_id, self.owner_id)
        await interaction.response.send_modal(modal)
    
    @discord.ui.button(label="üü¢ OUVERT", style=discord.ButtonStyle.success, emoji="üü¢", row=0)
    async def set_open(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Mode ouvert - tout le monde peut rejoindre"""
        
        channel = interaction.guild.get_channel(self.channel_id)
        if not channel:
            await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)
            return
        
        # Mettre √† jour les permissions
        try:
            await channel.set_permissions(interaction.guild.default_role, view_channel=True, connect=True)
            
            embed = discord.Embed(
                title="‚úÖ **MODE OUVERT ACTIV√â**",
                description="üü¢ **Tout le monde peut maintenant rejoindre ce salon !**",
                color=discord.Color.green()
            )
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    
    @discord.ui.button(label="üü° FERM√â", style=discord.ButtonStyle.primary, emoji="üü°", row=0)
    async def set_closed(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Mode ferm√© - seulement la whitelist"""
        
        channel = interaction.guild.get_channel(self.channel_id)
        if not channel:
            await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)
            return
        
        try:
            # Bloquer l'acc√®s par d√©faut
            await channel.set_permissions(interaction.guild.default_role, view_channel=True, connect=False)
            
            embed = discord.Embed(
                title="‚úÖ **MODE FERM√â ACTIV√â**",
                description="üü° **Seuls les membres de la whitelist peuvent rejoindre !**\n\n"
                           "Utilisez les autres boutons pour g√©rer la whitelist.",
                color=discord.Color.gold()
            )
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    
    @discord.ui.button(label="üî¥ PRIV√â", style=discord.ButtonStyle.danger, emoji="üî¥", row=0)
    async def set_private(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Mode priv√© - invisible sauf whitelist"""
        
        channel = interaction.guild.get_channel(self.channel_id)
        if not channel:
            await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)
            return
        
        try:
            # Rendre invisible
            await channel.set_permissions(interaction.guild.default_role, view_channel=False, connect=False)
            
            embed = discord.Embed(
                title="‚úÖ **MODE PRIV√â ACTIV√â**",
                description="üî¥ **Le salon est maintenant invisible !**\n\n"
                           "Seule la whitelist peut voir et rejoindre.",
                color=discord.Color.red()
            )
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    
    @discord.ui.button(label="üë• LIMITE", style=discord.ButtonStyle.secondary, emoji="üë•", row=1)
    async def set_limit(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Changer la limite d'utilisateurs"""
        
        modal = SetLimitModal(self.channel_id)
        await interaction.response.send_modal(modal)
    
    @discord.ui.button(label="‚úèÔ∏è RENOMMER", style=discord.ButtonStyle.secondary, emoji="‚úèÔ∏è", row=1)
    async def rename_channel(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Renommer le salon"""
        
        modal = RenameChannelModal(self.channel_id)
        await interaction.response.send_modal(modal)
    
    @discord.ui.button(label="üö™ EXPULSER", style=discord.ButtonStyle.danger, emoji="üö™", row=1)
    async def kick_member(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Expulser un membre du salon"""
        
        channel = interaction.guild.get_channel(self.channel_id)
        if not channel or not hasattr(channel, 'members'):
            await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)
            return
        
        if len(channel.members) <= 1:
            await interaction.response.send_message("‚ùå Il n'y a personne d'autre √† expulser !", ephemeral=True)
            return
        
        # Cr√©er une s√©lection des membres
        view = KickMemberView(channel, interaction.user.id)
        
        embed = discord.Embed(
            title="üö™ **EXPULSER UN MEMBRE**",
            description="S√©lectionnez le membre √† expulser du salon :",
            color=discord.Color.orange()
        )
        
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
    
    @discord.ui.button(label="‚ùå SUPPRIMER", style=discord.ButtonStyle.danger, emoji="‚ùå", row=1)
    async def delete_channel(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Supprimer le salon temporaire"""
        
        embed = discord.Embed(
            title="‚ö†Ô∏è **CONFIRMATION DE SUPPRESSION**",
            description="**√ätes-vous s√ªr de vouloir supprimer ce salon ?**\n\n"
                       "Cette action est **irr√©versible** !",
            color=discord.Color.red()
        )
        
        view = DeleteConfirmView(self.channel_id)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)


class ChangeOwnerModal(discord.ui.Modal):
    """Modal pour changer le propri√©taire"""
    
    def __init__(self, channel_id: int, current_owner: int):
        super().__init__(title="üëë Changer le propri√©taire")
        self.channel_id = channel_id
        self.current_owner = current_owner
        
        self.user_input = discord.ui.TextInput(
            label="Nouvel propri√©taire (ID ou mention)",
            placeholder="@username ou 123456789",
            required=True,
            max_length=100
        )
        self.add_item(self.user_input)
    
    async def on_submit(self, interaction: discord.Interaction):
        # Logique pour changer le propri√©taire
        user_input = self.user_input.value.strip()
        
        # Extraire l'ID de l'utilisateur
        user_id = None
        if user_input.startswith('<@') and user_input.endswith('>'):
            user_id = int(user_input[2:-1].replace('!', ''))
        elif user_input.isdigit():
            user_id = int(user_input)
        
        if not user_id:
            await interaction.response.send_message("‚ùå Format invalide ! Utilisez @username ou l'ID", ephemeral=True)
            return
        
        new_owner = interaction.guild.get_member(user_id)
        if not new_owner:
            await interaction.response.send_message("‚ùå Utilisateur introuvable !", ephemeral=True)
            return
        
        embed = discord.Embed(
            title="‚úÖ **PROPRI√âTAIRE CHANG√â**",
            description=f"**Nouveau propri√©taire:** {new_owner.mention}",
            color=discord.Color.green()
        )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)


class SetLimitModal(discord.ui.Modal):
    """Modal pour d√©finir la limite d'utilisateurs"""
    
    def __init__(self, channel_id: int):
        super().__init__(title="üë• D√©finir la limite")
        self.channel_id = channel_id
        
        self.limit_input = discord.ui.TextInput(
            label="Limite d'utilisateurs (0 = illimit√©)",
            placeholder="10",
            required=True,
            max_length=2
        )
        self.add_item(self.limit_input)
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            limit = int(self.limit_input.value)
            if limit < 0 or limit > 99:
                await interaction.response.send_message("‚ùå Limite doit √™tre entre 0 et 99 !", ephemeral=True)
                return
            
            channel = interaction.guild.get_channel(self.channel_id)
            if channel:
                await channel.edit(user_limit=limit)
                
                embed = discord.Embed(
                    title="‚úÖ **LIMITE MODIFI√âE**",
                    description=f"**Nouvelle limite:** {limit if limit > 0 else 'Illimit√©e'}",
                    color=discord.Color.green()
                )
                
                await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)
                
        except ValueError:
            await interaction.response.send_message("‚ùå Veuillez entrer un nombre valide !", ephemeral=True)


class RenameChannelModal(discord.ui.Modal):
    """Modal pour renommer le salon"""
    
    def __init__(self, channel_id: int):
        super().__init__(title="‚úèÔ∏è Renommer le salon")
        self.channel_id = channel_id
        
        self.name_input = discord.ui.TextInput(
            label="Nouveau nom du salon",
            placeholder="üé§ Mon Super Salon",
            required=True,
            max_length=100
        )
        self.add_item(self.name_input)
    
    async def on_submit(self, interaction: discord.Interaction):
        new_name = self.name_input.value.strip()
        
        if len(new_name) < 1:
            await interaction.response.send_message("‚ùå Le nom ne peut pas √™tre vide !", ephemeral=True)
            return
        
        channel = interaction.guild.get_channel(self.channel_id)
        if channel:
            try:
                await channel.edit(name=new_name)
                
                embed = discord.Embed(
                    title="‚úÖ **SALON RENOMM√â**",
                    description=f"**Nouveau nom:** {new_name}",
                    color=discord.Color.green()
                )
                
                await interaction.response.send_message(embed=embed, ephemeral=True)
            except Exception as e:
                await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Salon introuvable !", ephemeral=True)


class KickMemberView(discord.ui.View):
    """Vue pour s√©lectionner un membre √† expulser"""
    
    def __init__(self, channel: discord.VoiceChannel, owner_id: int):
        super().__init__(timeout=60)
        self.channel = channel
        self.owner_id = owner_id
        
        # Cr√©er un s√©lecteur avec les membres du salon (sauf le propri√©taire)
        options = []
        for member in channel.members:
            if member.id != owner_id and not member.bot:
                options.append(discord.SelectOption(
                    label=member.display_name,
                    value=str(member.id),
                    description=f"Expulser {member.display_name}",
                    emoji="üö™"
                ))
        
        if options:
            self.member_select = discord.ui.Select(
                placeholder="S√©lectionner un membre √† expulser...",
                options=options[:25]  # Max 25 options
            )
            self.member_select.callback = self.kick_selected_member
            self.add_item(self.member_select)
    
    async def kick_selected_member(self, interaction: discord.Interaction):
        """Expulser le membre s√©lectionn√©"""
        
        member_id = int(self.member_select.values[0])
        member = interaction.guild.get_member(member_id)
        
        if not member:
            await interaction.response.send_message("‚ùå Membre introuvable !", ephemeral=True)
            return
        
        try:
            await member.move_to(None, reason=f"Expuls√© par {interaction.user}")
            
            embed = discord.Embed(
                title="‚úÖ **MEMBRE EXPULS√â**",
                description=f"**{member.mention}** a √©t√© expuls√© du salon !",
                color=discord.Color.green()
            )
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Impossible d'expulser: {e}", ephemeral=True)


class DeleteConfirmView(discord.ui.View):
    """Confirmation de suppression du salon"""
    
    def __init__(self, channel_id: int):
        super().__init__(timeout=30)
        self.channel_id = channel_id
    
    @discord.ui.button(label="‚úÖ OUI, SUPPRIMER", style=discord.ButtonStyle.danger, emoji="‚úÖ")
    async def confirm_delete(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Confirmer la suppression"""
        
        channel = interaction.guild.get_channel(self.channel_id)
        if channel:
            try:
                await channel.delete(reason=f"Suppression demand√©e par {interaction.user}")
                
                embed = discord.Embed(
                    title="‚úÖ **SALON SUPPRIM√â**",
                    description="Le salon vocal temporaire a √©t√© supprim√© !",
                    color=discord.Color.green()
                )
                
                await interaction.response.send_message(embed=embed, ephemeral=True)
                
            except Exception as e:
                await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Salon d√©j√† supprim√© !", ephemeral=True)
    
    @discord.ui.button(label="‚ùå ANNULER", style=discord.ButtonStyle.secondary, emoji="‚ùå")
    async def cancel_delete(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Annuler la suppression"""
        
        embed = discord.Embed(
            title="üîÑ **SUPPRESSION ANNUL√âE**",
            description="Le salon reste actif !",
            color=discord.Color.blue()
        )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)


async def setup(bot):
    """Charge le module HubVocalDraftBot"""
    await bot.add_cog(HubVocal(bot))
    print("üöÄ [OK] HubVocalDraftBot charg√© - Syst√®me complet de salons temporaires !")
