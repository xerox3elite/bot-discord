"""
üêõ ARSENAL BUG REPORT SYSTEM - Modal Ultra-Rapide
Syst√®me de signalement de bugs avec modal et s√©lection de commandes
Sauvegarde en JSON avec pr√©dictions d'erreurs automatiques
"""

import discord
from discord import app_commands
from discord.ext import commands
import datetime
import json
import os
import glob
from typing import Optional, List

class BugReportModal(discord.ui.Modal, title='üêõ Signaler un Bug Arsenal'):
    """Modal ultra-rapide pour signaler des bugs"""
    
    def __init__(self, command_name: str = "Non sp√©cifi√©"):
        super().__init__()
        self.command_name = command_name
    
    description = discord.ui.TextInput(
        label='üìù D√©crivez le bug rapidement',
        placeholder='Ex: La commande ne r√©pond pas, erreur timeout, embed cass√©...',
        max_length=500,
        style=discord.TextStyle.paragraph,
        required=True
    )
    
    steps = discord.ui.TextInput(
        label='üîÑ Comment reproduire le bug? (optionnel)',
        placeholder='Ex: Utiliser /music play puis /music stop...',
        max_length=300,
        style=discord.TextStyle.paragraph,
        required=False
    )
    
    expected = discord.ui.TextInput(
        label='‚úÖ R√©sultat attendu (optionnel)', 
        placeholder='Ex: La musique devrait s\'arr√™ter...',
        max_length=200,
        required=False
    )

    async def on_submit(self, interaction: discord.Interaction):
        """Traitement du bug report"""
        
        # Pr√©dictions d'erreurs automatiques bas√©es sur la commande
        error_predictions = get_error_predictions(self.command_name, self.description.value)
        
        bug_data = {
            "id": f"BUG_{int(datetime.datetime.now().timestamp())}",
            "timestamp": datetime.datetime.now().isoformat(),
            "user_id": interaction.user.id,
            "user_name": str(interaction.user),
            "guild_id": interaction.guild.id if interaction.guild else None,
            "guild_name": interaction.guild.name if interaction.guild else "DM",
            "command": self.command_name,
            "description": self.description.value,
            "reproduction_steps": self.steps.value or "Non sp√©cifi√©",
            "expected_result": self.expected.value or "Non sp√©cifi√©",
            "error_predictions": error_predictions,
            "status": "nouveau",
            "priority": determine_priority(self.description.value, self.command_name)
        }
        
        # Sauvegarder le bug
        save_bug_report(bug_data)
        
        # R√©ponse avec embed styl√©
        embed = discord.Embed(
            title="üêõ Bug Report Enregistr√© !",
            description=f"**ID**: `{bug_data['id']}`\n**Commande**: `{self.command_name}`",
            color=discord.Color.green(),
            timestamp=datetime.datetime.now()
        )
        
        embed.add_field(
            name="üìù Description",
            value=f"```{self.description.value[:100]}{'...' if len(self.description.value) > 100 else ''}```",
            inline=False
        )
        
        if error_predictions:
            predictions_text = "\n".join([f"‚Ä¢ {pred}" for pred in error_predictions[:3]])
            embed.add_field(
                name="üîÆ Pr√©dictions d'Erreurs",
                value=predictions_text,
                inline=False
            )
        
        embed.add_field(
            name="‚ö° Temps de Traitement Estim√©",
            value=f"**{get_estimated_time(bug_data['priority'])}**",
            inline=True
        )
        
        embed.add_field(
            name="üéØ Priorit√©",
            value=f"**{bug_data['priority'].upper()}**",
            inline=True
        )
        
        embed.set_footer(
            text="Merci de contribuer √† am√©liorer Arsenal ! ‚Ä¢ Utilisez /voirbug pour suivre",
            icon_url=interaction.user.display_avatar.url
        )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

class CommandSelectView(discord.ui.View):
    """Vue avec s√©lecteur de commandes pour signaler un bug"""
    
    def __init__(self):
        super().__init__(timeout=300)
        
        # R√©cup√©rer les commandes disponibles
        commands = get_arsenal_commands()
        
        # Cr√©er les options (max 25 par s√©lecteur)
        options = []
        for cmd in commands[:24]:  # Garder de la place pour "Autre"
            emoji = get_command_emoji(cmd)
            options.append(discord.SelectOption(
                label=cmd,
                description=f"Signaler un bug avec /{cmd}",
                emoji=emoji
            ))
        
        options.append(discord.SelectOption(
            label="ü§∑ Autre/Non list√©",
            description="Commande non list√©e ou bug g√©n√©ral",
            emoji="‚ùì"
        ))
        
        self.command_select.options = options
    
    @discord.ui.select(placeholder="üéØ S√©lectionnez la commande avec le bug...")
    async def command_select(self, interaction: discord.Interaction, select: discord.ui.Select):
        """S√©lection de commande"""
        selected_command = select.values[0]
        
        if selected_command == "ü§∑ Autre/Non list√©":
            selected_command = "Autre"
        
        # Ouvrir le modal avec la commande pr√©-s√©lectionn√©e
        modal = BugReportModal(selected_command)
        await interaction.response.send_modal(modal)

class ArsenalBugReport(commands.Cog):
    """Syst√®me de signalement de bugs ultra-rapide pour Arsenal"""
    
    def __init__(self, bot):
        self.bot = bot
        self.bugs_file = "arsenal_bugs.json"
        self.ensure_bugs_file()
    
    def ensure_bugs_file(self):
        """S'assurer que le fichier bugs existe"""
        if not os.path.exists(self.bugs_file):
            with open(self.bugs_file, 'w', encoding='utf-8') as f:
                json.dump([], f, indent=2)
    
    @app_commands.command(name="bugreport", description="üêõ Signaler un bug Arsenal en 5 secondes")
    async def bug_report(self, interaction: discord.Interaction):
        """Commande pour signaler un bug rapidement"""
        
        embed = discord.Embed(
            title="üêõ Bug Report Arsenal",
            description="**Signalez un bug en 5 secondes chrono !**\n\nüéØ **√âtape 1**: S√©lectionnez la commande\n‚ö° **√âtape 2**: D√©crivez rapidement le probl√®me\n‚úÖ **√âtape 3**: C'est tout !",
            color=discord.Color.orange()
        )
        
        embed.add_field(
            name="üöÄ Pourquoi c'est rapide ?",
            value="‚Ä¢ S√©lection automatique de commande\n‚Ä¢ Pr√©dictions d'erreurs int√©gr√©es\n‚Ä¢ Priorit√© calcul√©e automatiquement\n‚Ä¢ Sauvegarde instantan√©e",
            inline=True
        )
        
        embed.add_field(
            name="üîÆ Intelligence Int√©gr√©e",
            value="‚Ä¢ D√©tection d'erreurs communes\n‚Ä¢ Suggestions de solutions\n‚Ä¢ Estimation temps de fix\n‚Ä¢ Classement par priorit√©",
            inline=True
        )
        
        embed.set_footer(text="Arsenal Bug Report System ‚Ä¢ Cliquez sur le menu ci-dessous")
        
        view = CommandSelectView()
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
    
    @app_commands.command(name="voirbug", description="üëÅÔ∏è Voir les bugs report√©s (Cr√©ateur uniquement)")
    async def voir_bugs(self, interaction: discord.Interaction, status: Optional[str] = None, limit: Optional[int] = 10):
        """Voir les bugs report√©s"""
        
        # V√©rifier permissions (tu peux ajuster l'ID)
        creator_id = 123456789  # Remplace par ton ID Discord
        if interaction.user.id != creator_id:
            await interaction.response.send_message("‚ùå Seul le cr√©ateur peut voir les bugs !", ephemeral=True)
            return
        
        # Charger les bugs
        bugs = load_bug_reports()
        
        if not bugs:
            embed = discord.Embed(
                title="üìã Aucun Bug Report√©",
                description="Aucun bug n'a √©t√© signal√© pour le moment !",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
        
        # Filtrer par status si sp√©cifi√©
        if status:
            bugs = [bug for bug in bugs if bug.get('status', 'nouveau') == status.lower()]
        
        # Limiter le nombre
        bugs = bugs[-limit:] if limit else bugs[-10:]  # Les plus r√©cents
        
        embed = discord.Embed(
            title="üêõ Bug Reports Arsenal",
            description=f"**{len(bugs)} bugs** (sur {len(load_bug_reports())} total)",
            color=discord.Color.blue()
        )
        
        for bug in bugs:
            priority_emoji = {"critique": "üî•", "haute": "‚ö†Ô∏è", "moyenne": "üìå", "basse": "üí≠"}.get(bug.get('priority', 'moyenne'), "üìå")
            
            embed.add_field(
                name=f"{priority_emoji} {bug['id']} - /{bug['command']}",
                value=(
                    f"**User**: {bug['user_name']}\n"
                    f"**Status**: {bug.get('status', 'nouveau').title()}\n"
                    f"**Description**: {bug['description'][:80]}{'...' if len(bug['description']) > 80 else ''}\n"
                    f"**Date**: <t:{int(datetime.datetime.fromisoformat(bug['timestamp']).timestamp())}:R>"
                ),
                inline=False
            )
        
        embed.set_footer(text=f"Utilisez /voirbug status:nouveau pour voir seulement les nouveaux")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

# ========================================
# FONCTIONS UTILITAIRES 
# ========================================

def get_arsenal_commands() -> List[str]:
    """R√©cup√®re la liste des commandes Arsenal disponibles"""
    commands = [
        "music", "play", "stop", "skip", "queue", "volume",
        "ban", "kick", "mute", "warn", "timeout", 
        "help", "info", "ping", "stats", "profile",
        "economy", "balance", "shop", "buy", "daily",
        "hunt", "royal", "crypto", "wallet", "invest",
        "config", "setup", "automod", "logs", "welcome",
        "tempvoice", "ticket", "poll", "giveaway", "level",
        "leaderboard", "xp", "rank", "rep", "marriage"
    ]
    return sorted(commands)

def get_command_emoji(command: str) -> str:
    """Retourne un emoji pour une commande"""
    emojis = {
        "music": "üéµ", "play": "‚ñ∂Ô∏è", "stop": "‚èπÔ∏è", "skip": "‚è≠Ô∏è",
        "ban": "üî®", "kick": "üë¢", "mute": "üîá", "warn": "‚ö†Ô∏è",
        "help": "‚ùì", "info": "‚ÑπÔ∏è", "ping": "üèì", "stats": "üìä",
        "economy": "üí∞", "balance": "üí≥", "shop": "üõí", "daily": "üìÖ",
        "config": "‚öôÔ∏è", "setup": "üîß", "automod": "üõ°Ô∏è", "logs": "üìã"
    }
    return emojis.get(command, "üîß")

def get_error_predictions(command: str, description: str) -> List[str]:
    """G√©n√®re des pr√©dictions d'erreurs bas√©es sur la commande et description"""
    predictions = []
    
    desc_lower = description.lower()
    
    # Pr√©dictions par commande
    if command in ["music", "play", "stop", "skip"]:
        if "timeout" in desc_lower or "lent" in desc_lower:
            predictions.append("Possible probl√®me de connexion r√©seau")
        if "permission" in desc_lower or "erreur" in desc_lower:
            predictions.append("V√©rifier les permissions vocales du bot")
        if "lag" in desc_lower or "coup√©" in desc_lower:
            predictions.append("Probl√®me de stabilit√© de connexion Discord")
    
    elif command in ["ban", "kick", "mute", "warn"]:
        if "permission" in desc_lower:
            predictions.append("Bot manque de permissions de mod√©ration")
        if "erreur" in desc_lower:
            predictions.append("Hi√©rarchie des r√¥les incorrecte")
    
    elif command in ["economy", "balance", "shop"]:
        if "erreur" in desc_lower or "bug" in desc_lower:
            predictions.append("Possible corruption de base de donn√©es")
        if "lent" in desc_lower:
            predictions.append("Optimisation requise pour les requ√™tes DB")
    
    # Pr√©dictions g√©n√©rales
    if "crash" in desc_lower or "plante" in desc_lower:
        predictions.append("Exception non g√©r√©e dans le code")
    if "lent" in desc_lower or "timeout" in desc_lower:
        predictions.append("Probl√®me de performance ou r√©seau")
    if "embed" in desc_lower:
        predictions.append("Formatage embed incorrect")
    
    return predictions[:3]  # Max 3 pr√©dictions

def determine_priority(description: str, command: str) -> str:
    """D√©termine la priorit√© du bug automatiquement"""
    desc_lower = description.lower()
    
    # Mots-cl√©s critiques
    if any(word in desc_lower for word in ["crash", "plante", "erreur fatale", "impossible"]):
        return "critique"
    
    # Commandes importantes
    if command in ["ban", "kick", "music", "economy"] and "erreur" in desc_lower:
        return "haute"
    
    # Probl√®mes de performance
    if any(word in desc_lower for word in ["lent", "lag", "timeout", "freeze"]):
        return "moyenne"
    
    return "basse"

def get_estimated_time(priority: str) -> str:
    """Retourne le temps estim√© de r√©solution"""
    times = {
        "critique": "üî• 24h max",
        "haute": "‚ö†Ô∏è 2-3 jours", 
        "moyenne": "üìå 1 semaine",
        "basse": "üí≠ Prochaine mise √† jour"
    }
    return times.get(priority, "üìå 1 semaine")

def save_bug_report(bug_data: dict):
    """Sauvegarde un bug report"""
    bugs = load_bug_reports()
    bugs.append(bug_data)
    
    with open("arsenal_bugs.json", 'w', encoding='utf-8') as f:
        json.dump(bugs, f, indent=2, ensure_ascii=False)

def load_bug_reports() -> List[dict]:
    """Charge les bug reports"""
    if not os.path.exists("arsenal_bugs.json"):
        return []
    
    try:
        with open("arsenal_bugs.json", 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return []

async def setup(bot):
    await bot.add_cog(ArsenalBugReport(bot))
